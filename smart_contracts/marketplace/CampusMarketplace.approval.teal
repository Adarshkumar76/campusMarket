#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 8
    bytecblock "item_count" "prices" 0x151f7c75
    txn ApplicationID
    bnz main_after_if_else@2
    // marketplace/contract.py:31
    // self.item_count = UInt64(0)
    bytec_0 // "item_count"
    intc_1 // 0
    app_global_put

main_after_if_else@2:
    // marketplace/contract.py:21
    // class CampusMarketplace(ARC4Contract):
    txn OnCompletion
    !
    assert
    txn ApplicationID
    bz main_create_NoOp@10
    pushbytess 0x95e39abb 0x7b2bf539 0x0e1a79ef 0xf2dda887 // method "list_item(uint64)uint64", method "buy_item(uint64,pay)void", method "get_price(uint64)uint64", method "get_item_count()uint64"
    txna ApplicationArgs 0
    match list_item buy_item get_price get_item_count
    err

main_create_NoOp@10:
    // marketplace/contract.py:21
    // class CampusMarketplace(ARC4Contract):
    pushbytes 0x4c5c61ba // method "create()void"
    txna ApplicationArgs 0
    match main_create_route@11
    err

main_create_route@11:
    // marketplace/contract.py:38
    // self.item_count = UInt64(0)
    bytec_0 // "item_count"
    intc_1 // 0
    app_global_put
    // marketplace/contract.py:35
    // @arc4.abimethod(create="require")
    intc_0 // 1
    return


// contract.CampusMarketplace.list_item[routing]() -> void:
list_item:
    // marketplace/contract.py:40
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // marketplace/contract.py:48
    // assert Txn.sender == Global.creator_address, "only seller can list"
    txn Sender
    global CreatorAddress
    ==
    assert // only seller can list
    // marketplace/contract.py:49
    // assert price.native > UInt64(0), "price must be > 0"
    btoi
    dup
    assert // price must be > 0
    // marketplace/contract.py:51
    // self.item_count += 1
    intc_1 // 0
    bytec_0 // "item_count"
    app_global_get_ex
    assert // check self.item_count exists
    intc_0 // 1
    +
    bytec_0 // "item_count"
    dig 1
    app_global_put
    // marketplace/contract.py:52
    // self.prices[self.item_count] = price.native
    itob
    bytec_1 // "prices"
    dig 1
    concat
    uncover 2
    itob
    box_put
    // marketplace/contract.py:40
    // @arc4.abimethod()
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// contract.CampusMarketplace.buy_item[routing]() -> void:
buy_item:
    // marketplace/contract.py:56
    // @arc4.abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // marketplace/contract.py:67
    // price = self.prices[item_id.native]
    swap
    btoi
    itob
    bytec_1 // "prices"
    swap
    concat
    dup
    box_get
    assert // check self.prices entry exists
    btoi
    // marketplace/contract.py:68
    // assert price > UInt64(0), "item not available"
    dup
    assert // item not available
    // marketplace/contract.py:70
    // assert pay_txn.receiver == Global.creator_address, "pay the seller"
    dig 2
    gtxns Receiver
    global CreatorAddress
    ==
    assert // pay the seller
    // marketplace/contract.py:71
    // assert pay_txn.amount == price, "wrong payment amount"
    uncover 2
    gtxns Amount
    ==
    assert // wrong payment amount
    // marketplace/contract.py:73-74
    // # mark as sold (set price to 0)
    // self.prices[item_id.native] = UInt64(0)
    intc_1 // 0
    itob
    box_put
    // marketplace/contract.py:56
    // @arc4.abimethod()
    intc_0 // 1
    return


// contract.CampusMarketplace.get_price[routing]() -> void:
get_price:
    // marketplace/contract.py:76
    // @arc4.abimethod(readonly=True)
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    // marketplace/contract.py:79
    // price, _exists = self.prices.maybe(item_id.native)
    btoi
    itob
    bytec_1 // "prices"
    swap
    concat
    box_get
    swap
    btoi
    swap
    // marketplace/contract.py:80
    // if _exists:
    bz get_price_after_if_else@3
    // marketplace/contract.py:81
    // return arc4.UInt64(price)
    dup
    itob

get_price_after_inlined_contract.CampusMarketplace.get_price@4:
    // marketplace/contract.py:76
    // @arc4.abimethod(readonly=True)
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

get_price_after_if_else@3:
    // marketplace/contract.py:82
    // return arc4.UInt64(0)
    pushbytes 0x0000000000000000
    // marketplace/contract.py:76
    // @arc4.abimethod(readonly=True)
    b get_price_after_inlined_contract.CampusMarketplace.get_price@4


// contract.CampusMarketplace.get_item_count[routing]() -> void:
get_item_count:
    // marketplace/contract.py:87
    // return arc4.UInt64(self.item_count)
    intc_1 // 0
    bytec_0 // "item_count"
    app_global_get_ex
    assert // check self.item_count exists
    itob
    // marketplace/contract.py:84
    // @arc4.abimethod(readonly=True)
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return
